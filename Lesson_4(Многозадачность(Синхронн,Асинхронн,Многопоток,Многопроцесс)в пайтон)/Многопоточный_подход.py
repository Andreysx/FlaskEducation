# Многопоточный подход
# Многопоточный код — это подход к многозадачности, при котором программа
# может выполнять несколько задач одновременно в разных потоках выполнения.
# Каждый поток выполняет свою задачу независимо от других потоков, что позволяет
# улучшить производительность программы.
# Примеры многопоточных операций в Python:
# ● загрузка данных из нескольких файлов одновременно
# ● параллельная обработка большого объема данных
# ● одновременное выполнение нескольких запросов к базе данных
# ● многопоточный веб-сервер, обрабатывающий несколько запросов
# одновременно
# Преимущества многопоточного кода:
# ● увеличение производительности программы за счет параллельного
# выполнения задач
# ● возможность выполнения нескольких задач одновременно без блокировки
# Недостатки многопоточного кода:
# ● возможность возникновения конкуренции за ресурсы
# ● сложность отладки и тестирования многопоточных программ
# ● возможность блокировки потоков выполнения
# Для решения проблем, связанных с конкуренцией за ресурсы и блокировками
# потоков, можно использовать механизмы синхронизации, такие как блокировки и
# семафоры. Однако, неправильное использование этих механизмов может привести
# к дедлокам (deadlock) и другим проблемам.
# При разработке многопоточных программ необходимо учитывать особенности
# языка Python, такие как GIL (Global Interpreter Lock), который ограничивает
# параллелизм в исполнении Python-кода. Это означает, что в Python нельзя
# использовать несколько ядер процессора для выполнения одной программы.
# В целом, многопоточный подход позволяет улучшить производительность
# программы и выполнить несколько задач одновременно без блокировки. Однако,
# при разработке многопоточных программ необходимо учитывать особенности
# языка Python и правильно использовать механизмы синхронизации для избежания
# проблем.
#
#
# Примеры программа на Python
# Пример 1:
#
# import threading
# import time
#
#
# def worker(num):
#     print(f"Начало работы потока {num}")
#     time.sleep(3)
#     print(f"Конец работы потока {num}")
#
#
# threads = []
# for i in range(5):
#     t = threading.Thread(target=worker, args=(i, ))
#     threads.append(t)
#     t.start()
#
# for t in threads:
#     t.join()
#
# print("Все потоки завершили работу")
#
# Эта программа создает 5 потоков и запускает функцию worker() в каждом из них.
# Функция worker() занимает 3 секунды на выполнение. Весь код работает
# многопоточно, то есть каждый поток работает независимо от других, и выполнение
# программы не блокируется на время выполнения функции.
#
#
# Пример 2:
# import threading
# import time
#
#
# def worker(num):
#     print(f"Начало работы потока {num}")
#     time.sleep(3)
#     print(f"Конец работы потока {num}")
#
#
# threads = []
# for i in range(5):
#     t = threading.Thread(target=worker, args=(i, ))
#     threads.append(t)
#
# for t in threads:
#     t.start()
#     t.join()
#
# print("Все потоки завершили работу")
#
# Эта программа создает 5 потоков и запускает функцию worker() в каждом из них.
# Функция worker() занимает 3 секунды на выполнение. Весь код работает
# многопоточно, но в отличие от предыдущего примера, потоки запускаются и
# завершаются последовательно, блокируя выполнение программы на время
# выполнения каждого потока.
#
#
# Пример 3:
# import threading
#
# counter = 0
#
# def increment():
#     global counter
#     for _ in range(1_000_000):
#         counter += 1
#     print(f"Значение счетчика: {counter:_}")
#
#
# threads = []
# for i in range(5):
#     t = threading.Thread(target=increment)
#     threads.append(t)
#     t.start()
#
# for t in threads:
#     t.join()
#
# print(f"Значение счетчика в финале: {counter:_}")
#
# Эта программа создает 5 потоков и запускает функцию increment() в каждом из них.
# Функция increment() увеличивает значение глобальной переменной counter на 1
# миллион раз. Весь код работает многопоточно, но из-за того, что несколько потоков
# работают с одной переменной, может возникнуть проблема гонки данных (race
# condition), когда результат выполнения программы может быть непредсказуемым.
# Многопоточный код позволяет выполнять несколько задач параллельно, что может
# значительно ускорить выполнение программы. Однако при работе с общими
# ресурсами (например, глобальными переменными) может возникнуть проблема
# гонки данных, которую необходимо учитывать при написании многопоточного кода.
