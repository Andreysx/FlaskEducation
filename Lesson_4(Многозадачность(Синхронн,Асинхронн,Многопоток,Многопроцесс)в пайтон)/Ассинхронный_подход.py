# Асинхронный подход
# Асинхронный код — это подход к многозадачности, при котором программа может
# выполнять несколько задач одновременно без создания отдельных процессов или
# потоков. Вместо этого задачи выполняются в рамках одного потока выполнения, но
# с использованием механизмов событий и обратных вызовов.
#
# Примеры асинхронных операций в Python:
# ● обработка сетевых запросов
# ● чтение и запись в файлы
# ● обработка пользовательских событий в графическом интерфейсе
# Преимущества асинхронного кода:
# ● более эффективное использование ресурсов процессора и памяти
# ● возможность обрабатывать большое количество задач одновременно без
# создания отдельных процессов или потоков
# ● упрощение кода и улучшение его читаемости
#
# Недостатки асинхронного кода:
# ● сложность отладки и тестирования
# ● возможность возникновения ошибок из-за неправильного использования
# механизмов событий и обратных вызовов
# ● ограниченная поддержка сторонними библиотеками
#
# Для разработки асинхронного кода в Python используется модуль asyncio, который
# предоставляет механизмы для организации асинхронного выполнения задач.
# Ключевыми понятиями в asyncio являются корутины, события и цикл событий.
#
# Корутины — это функции, которые могут приостанавливать свое выполнение,
# чтобы дать возможность другим корутинам выполниться.
#
# События используются для уведомления корутин о том, что какое-то событие
# произошло (например, завершение сетевого запроса).
#
# Цикл событий — это основной механизм, который управляет выполнением корутин
# и обработкой событий.
# При разработке асинхронного кода необходимо учитывать особенности работы с
# корутинами и правильно использовать механизмы событий для избежания
# проблем. Также следует учитывать поддержку сторонними библиотеками и
# оптимизировать работу программы.
#
# В целом, асинхронный подход позволяет эффективно использовать ресурсы
# процессора и памяти, обрабатывать большое количество задач одновременно и
# упрощать код. Однако, при разработке асинхронного кода необходимо учитывать
# особенности работы с корутинами и правильно использовать механизмы событий
# для избежания проблем.
#
# Примеры программа на Python
# Пример 1:
#
# import asyncio
#
#
# async def print_numbers():
#     for i in range(10):
#         print(i)
#         await asyncio.sleep(1)
#
#
# async def print_letters():
#     for letter in ['a', 'b', 'c', 'd', 'e', 'f']:
#         print(letter)
#         await asyncio.sleep(0.5)
#
#
# async def main():
#     task1 = asyncio.create_task(print_numbers())
#     task2 = asyncio.create_task(print_letters())
#     await task1
#     await task2
#
#
# asyncio.run(main())
#
#
# Эта программа демонстрирует асинхронный код с использованием библиотеки
# asyncio. В функциях print_numbers() и print_letters() с помощью ключевого слова
# await осуществляется ожидание выполнения операции asyncio.sleep(), что
# позволяет переключаться между задачами без блокировки выполнения программы.
# В функции main() создаются две задачи, которые выполняются параллельно, а
# затем ожидается их завершение.
#
#
# Пример 2:
#
# import asyncio
#
#
# async def count():
#     print("Начало выполнения")
#     await asyncio.sleep(1)
#     print("Прошла 1 секунда")
#     await asyncio.sleep(2)
#     print("Прошло еще 2 секунды")
#     return "Готово"
#
# async def main():
#     result = await asyncio.gather(count(), count(), count())
#     print(result)
#
# asyncio.run(main())
#
#
# Эта программа демонстрирует асинхронный код с использованием функции
# asyncio.gather(), которая позволяет запускать несколько задач параллельно и
# ожидать их завершения. В функции count() с помощью ключевого слова await
# осуществляется ожидание выполнения операции asyncio.sleep(). В функции main()
# создаются три задачи с помощью функции count(), которые запускаются
# параллельно с помощью функции asyncio.gather(). Результаты выполнения задач
# выводятся на экран после их завершения.
#
#
# Пример 3:
#
# import asyncio
# from pathlib import Path
#
# async def process_file(file_path):
#     with open(file_path, 'r', encoding='utf-8') as f:
#         contents = f.read()
#         # do some processing with the file contents
#         print(f'{f.name} содержит {contents[:7]}...')
#
#
# async def main():
#     dir_path = Path('/path/to/directory')
#     dir_path = Path('.')
#         file_paths = [file_path for file_path in dir_path.iterdir()
#     if file_path.is_file()]
#         tasks = [asyncio.create_task(process_file(file_path)) for file_path in file_paths]
#         await asyncio.gather(*tasks)
#
#
# if __name__ == '__main__':
#     asyncio.run(main())
#
#
# Программа для асинхронной обработки большого количества файлов из примера 2
# работает следующим образом:
# 1. Определяется путь к директории, в которой находятся файлы, которые нужно
# обработать.
# 2. Используется метод iterdir() для получения списка файлов в каталоге, и метод
# is_file() для проверки, что это файлы, а не каталоги или другие объекты.
# 3. Создается список задач для обработки каждого файла с помощью функции
# asyncio.create_task(), где каждая задача вызывает функцию process_file() для
# обработки соответствующего файла.
# 4. Запускается выполнение всех задач с помощью функции asyncio.gather().
# 5. Когда все задачи завершены, программа завершается.
# Функция process_file() открывает файл для чтения и считывает его содержимое с
# помощью метода read(). Затем происходит обработка содержимого файла (которая
# может быть любой, в зависимости от требований конкретной задачи). После этого
# файл закрывается.
# Таким образом, программа асинхронно обрабатывает каждый файл в директории,
# что позволяет ускорить выполнение задачи при большом количестве файлов.